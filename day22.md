# Project Discussion—WebSocket

In the previous article, when developing the Conjure Piglet Client, I mentioned the third-party library WebSocket. Initially, I naively thought that I could just find some Neovim plugins or Lua libraries and install them to get it done. However, once I started working on it, I realized it was much more difficult than I had initially imagined.

## Problem Overview

After trying several options, the one that came closest to my needs was the [lua-websockets](https://github.com/lipp/lua-websockets) library, while other options might only implement a WebSocket client or were not pure Lua implementations. Since I hoped that this conjure client wouldn't be too difficult to install in the future, I decided that a library installed via Luarocks would be the limit.

For ease of testing, I also installed [websocat](https://formulae.brew.sh/formula/websocat), so I could focus on testing WebSocket first, without needing to test WebSocket and CBOR together.

Soon after, I successfully created a WebSocket echo server using lua-websockets. Then, the first challenge appeared: "Although the client made with websocat could successfully connect to the WebSocket server running in Neovim, Neovim would completely freeze after the client disconnected."

## Solution Architecture

What was happening? The problem was that using lua-websockets within Neovim was inherently not quite rational. The lua-websockets library provides two asynchronous mechanisms: `lua-ev` or `copas` (coroutine), however, neither of these asynchronous mechanisms uses Neovim's `vim.uv` as its underlying layer. In other words, the aforementioned approach was equivalent to using two event loops (one from Neovim, and another from lua-websockets), which naturally made it very prone to the freezing described above.

After understanding the cause of the freeze, the reasonable solution became clear: there should only be one event loop. Therefore, I decided to modify the underlying layer of lua-websockets to make it depend on Neovim's `vim.uv`. Simply put, I decided to port lua-websockets to `vim.uv`.

After reading the source code of lua-websockets, I found that the focus of porting should be on `src/websocket/server_ev.lua`.

I used an LLM for this part of the porting. After trying two prompts, I finally completed a usable WebSocket server.

### Prompt 1

> Rewrite [src/websocket/server_ev.lua](https://github.com/lipp/lua-websockets/blob/master/src/websocket/server_ev.lua) so that it can run in Neovim. Note: The original implementation depends on four libraries: `ev`, `loop`, `websocket.ev_common`, `socket`. Please remove the dependencies on these libraries and instead use `vim.uv`. …

The code generated by Prompt 1 was largely usable, but one of the functions, `message_io`, was a serious hallucination, and this hallucination was quite reasonable because I didn't notice that `websocket.ev_common` was actually a major part of `server_ev.lua` itself, rather than an external dependency.

Therefore, I used a second prompt to correct this issue.

### Prompt 2

> Consider `message_io` within [src/websocket/ev_common.lua](https://github.com/lipp/lua-websockets/blob/master/src/websocket/ev_common.lua), which depends on `lua ev`'s `loop`. Please refactor `message_io`, and change the `sock` within `message_io` to the return value of `uv.new_tcp()` from `vim.uv`, meaning this `sock` has functions like `read_start`, `write` that can be called. ...

After two Prompts, I performed some simple manual debugging, and the WebSocket connection was established.

## Summary

To some extent, the problem solved this time was still a porting issue, just like day20 and day21 before. Within a large porting problem, there were smaller porting problems.

Because I had already identified the dependencies for this porting problem, the LLM's prompt could handle it smoothly. On the other hand, if the dependency relationships had not been clarified manually, the LLM's chance of success would have been very low.
