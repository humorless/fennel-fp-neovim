# Neovim Plugin Developmentâ€”How to debug?

There are two types of Runtime knowledge particularly useful for debugging:

1. How to inspect the internal state of the Runtime?
2. What is the internal execution order of the Runtime?

## Inspecting Internal State

There are several ways to help you inspect Neovim's internal state, which is crucial for debugging.

### :lua command

You can directly execute Lua code using :lua in the command line. This is a very convenient Ex command, especially suitable for quickly testing a few lines of code or checking variable values.

For example, when you want to confirm if a Lua module has loaded successfully, you can execute the command:

`:lua print(require('module.name'))`

If the module loads successfully, the `require` function will return the module's table, and then `:lua print(...)` will print the memory address of this Table (e.g., `table: 0x...`). If the module does not exist, `require` will throw an error. This is a simple but effective verification method.

### Viewing Output

When Neovim is running, all output generated by functions like `print`, `vim.notify`, etc., is recorded. You can view these historical messages using the following Ex command.

`:messages`

### Handling Lua Table Output

When you directly use the `print` function to output a Lua Table, you will usually only see a memory address similar to `table: 0x...` and not the specific content. This can cause significant trouble during debugging.

To solve this problem, you can use Neovim's built-in `vim.inspect` function, which can convert any Lua value (especially Tables) into a human-readable string format. This is a very practical tool for debugging, and does not require installing any additional plugins.

For example, you can use it in Ex commands or in Fennel code:

- In Ex commands

```
:lua print(vim.inspect({a = 5, b = "hello"}))
-- The output will be:
-- { a = 5, b = 'hello' }
```

- In Fennel code

```
(vim.inspect {:a 5 :b "hello"})
```

## Internal Execution Order

In Neovim plugin development, understanding the file loading order is crucial for debugging and correctly configuring plugins. Below are several common plugin initialization methods and their differences.

### plugin
Files under the `plugin/` directory are loaded immediately when Neovim starts, regardless of the file type you open. These files are typically used to set global keybindings, commands, or autocommands (`autocmd`), and these configurations should be active at all times.

### ftplugin (Filetype Plugin)
Files under the `ftplugin/` directory are only loaded when Neovim identifies a specific file type (`filetype`). For example, `~/.config/nvim/ftplugin/lua.lua` will only be executed when editing a Lua file. These files are suitable for setting language-specific keybindings, buffer-local options, or autocommands.

### after/plugin
Files under the `after/plugin/` directory are executed only after the files in the `plugin/` directory have finished loading. This is a very important concept; it provides a mechanism to override or modify other plugin settings.

For example, if you want to modify a global keybinding set by a plugin in the `plugin/` directory, you can create a file in the `after/plugin/` directory to redefine it. This ensures that your settings are loaded after the plugin's default settings, thereby successfully overriding them.

Simply put, `plugin` is for global settings, `ftplugin` is for specific file types, and `after/plugin` provides an opportunity to customize or override settings after all default plugins have been loaded. Understanding this execution order can help you more effectively manage and debug your Neovim configuration.

## Summary

Effective Neovim plugin debugging primarily relies on two key areas of knowledge: **inspecting internal state** and **understanding execution order**.

Of course, Neovim's commands for inspecting internal state are not limited to those mentioned above; there are many other commands. Similarly, the internal execution order also has many variations.

Incorporating the above concepts into your development workflow, and consulting the official documentation, will surely make debugging easier.
